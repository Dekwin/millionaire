/**
 * Created by igorkasyanenko on 25.04.16.
 */
var config = require('config');
var qs = require('querystring');
var routing = require('routing');
var dbModule = require('dbmodule');

var clients = [];
clients.setRemoveTimer = function (client) {

    setTimeout(function () {
        // console.log("client deleted");
        clients.splice(clients.indexOf(client), 1);
    }, 4000);
}

//dbModule.createTestQuestionsTable();


function Client(ip, syncDate, expired) {
    this.ip = ip;
    this.syncDate = syncDate;
    this.expired = expired;
}


function findByIP(ip) {
    var itemFound = null;
    clients.forEach(function (item, i, arr) {
        console.log(item.ip)
        if (item.ip == ip) {
            //  console.log("ip found : "+ip)
            itemFound = item;
        }
    });
    return itemFound;
}

/**
 * TODO: need to add bruteforce
 * @param body
 * @param clientIpAddress
 * @param callback
 */
function clientSync(body, clientIpAddress, callback) {
    var response = "";

    var postParams = qs.parse(body);
    if ("date" in postParams) {
        var clientSyncDate = postParams["date"];

        console.log("#Client(IP:"+clientIpAddress+") sent query.")
        console.log("Client(IP:"+clientIpAddress+") last synchronization time(longint): "+clientSyncDate+", server last update time: "+config.get('lastSyncTime'));



       // console.log("client: " + clientSyncDate + " lastSncTime: " + config.get('lastSyncTime'));

        var date = new Date();
        var timeMills = date.getTime();
        if (clientSyncDate < config.get('lastSyncTime') && findByIP(clientIpAddress) == null) {
            var client = new Client(clientIpAddress, clientSyncDate, timeMills);
            clients.push(client);
            clients.setRemoveTimer(client);

            console.log("Client(IP:"+clientIpAddress+") data needs to be updated.");

            if (clientSyncDate < config.get('lastDelTime')) {

                console.log("Client(IP:"+clientIpAddress+") will recieve all data from server.");

                callback("{\"delete_date\":" + timeMills + "}");
            } else {
                console.log("Client(IP:"+clientIpAddress+") will recieve only new data, which was added to server after time: "+clientSyncDate);
                //   console.log("aaaaaa millis "+timeMills)
                callback("{\"date\":" + timeMills + "}");
            }


        } else {
            console.log("Client(IP:"+clientIpAddress+") has actual data, nothing will send.");
            callback("{\"error\": \"no new questions\"}");
        }

    } else if ("hash" in postParams) {
        var clientHash = postParams["hash"];



        var client = findByIP(clientIpAddress);
        if (client != null) {


            var serverHashForClient = encrypt(client.expired);

            console.log("Client(IP:"+clientIpAddress+") sent hash: "+clientHash+" , server hash for this client: "
                +serverHashForClient+" , "+(serverHashForClient == clientHash ? " hashes are equal, new data will send to client." : " hashes are not equal, new data will not send to client."));
           // console.log("client hash = " + clientHash + " serv " + encrypt(client.expired))

            if (clientHash == serverHashForClient) {
                //   clients.splice(clients.indexOf(client),1);

                if (client.syncDate < config.get('lastDelTime')) {

                    dbModule.getAllQuestions(function (err, result) {
                        if (err) {
                            callback("{\"error\":\"db error\"}");
                        } else {
                            //     var r = 
                            // console.log(r);
                            callback("{\"response\":" + JSON.stringify(result) + "}");
                        }
                        // console.log(result);
                    });
                } else {

                    dbModule.getQuestions(client.syncDate, function (err, result) {
                        if (err) {
                            callback("{\"error\":\"db error\"}");
                        } else {
                            //     var r = 
                            // console.log(r);
                            callback("{\"response\":" + JSON.stringify(result) + "}");
                        }
                        // console.log(result);
                    });
                }

            } else {
                /**
                 * TODO: add removing clients
                 */

                //clients.splice(clients.indexOf(client),1);
                callback("{\"error\":\"not eq\"}");
                //  res.end("{not eq}");
            }
        } else {

            callback("{\"error\":\"client not found\"}");
        }

    } else {
        callback("{\"response\":\"not hash\"}");
    }

    // callback(response);

}

exports.clientSync = clientSync;

function encrypt(date) {
    var hash = require("crypto")
        .createHmac("sha256", config.get("mobileAppKey"))
        .update(date + config.get('mobileAppKey'))
        .digest("hex");
    // var hash = date+config.get('mobileAppKey');
    return hash;
}


routing.addRoutes({
    '/millionaire/sync': function (client, par) {

        if (client.req.method == 'POST') {
            var body = '';
            client.req.on('data', function (data) {
                body += data;
            });
            client.req.on('end', function () {
                clientSync(body, client.req.connection.remoteAddress, function (result) {

                    console.log("Server response:");
                    console.log(result)
                    client.res.end(result);
                });
            });
           // console.log("ip: " + client.req.connection.remoteAddress);
        } else {
            client.res.end("Access denied.");
        }

        return undefined;
    }
});

